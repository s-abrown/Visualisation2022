<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echelles</title>
    <style>
        svg {
            margin: 10px;
            border: 1px solid;
        }
        #tooltip{
            position: absolute;
            width: 200px;
            height: auto;
            padding: 10px;
            background-color: red;
            pointer-events: none;
        }
        #tooltip.hidden{
            display: none;

        }
        #tooltip.p{
            margin: 0px;
            font-family:'Times New Roman', Times, serif;
            font-size: 16px;
        }
    </style>
</head>

<body>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script>
        let canevas = d3.select('body')
            .append('svg')
            .attr('width', window.innerWidth - 20)
            .attr('height', window.innerHeight - 20)
            // ajouter le on ici
            // .on("click",fonctionClic);

         // 1. construire une échelle : valeurs continues (temps par exemple)
         // générer un type d'échelle
         const exempleEchelleDesX = d3.scaleLinear()
         // ajouter le domaine (données) : [valeur min, valeur max]
            .domain([0,20])
         // ajouter la projection : range  : [valeur min, valeur max]
            .range([0,window.innerWidth])

         console.log(exempleEchelleDesX(19))
         
         // l'échelle pour Y
         const exempleEchelleDesY = d3.scaleLinear()
            .domain([10,340])
            .range([window.innerHeight,0])

        // calculer des valeurs intermédiaires au-delà des nombres
        // avec deux valeurs
        const echelleTemp2 = d3.scaleLinear()
            .domain([-12,45])
            .range(['blue','red'])
    
        console.log(echelleTemp2(33))  ;
        
        // echelle temperature avec 3 couleurs
        // dans le domain ET dans le range
        const echelleTemp3 = d3.scaleLinear()
            .domain([-60,0,60])
            .range(['blue','white','red'])
    
        console.log(echelleTemp3(0))  ;

        // méthode raccourcie
        const echelleCourte = d3.scaleLinear([0,10],[-3,3]);

        // et quand on dépasse ?
        const JeDepasse = d3.scaleLinear([5,10],[10,20])
        console.log("Dépassement :", JeDepasse(30))

        // éviter le dépassement avec .clamp
        const JeNeDepassePas = d3.scaleLinear([5,10],[10,20]).clamp(true);
        console.log("Dépassement :", JeNeDepassePas(30))

        // travailler avec des données et extraire le minimum et le maximum
        // avec d3.extent
        const mesDonnees = [1,21,1,12,34,-5,46];
        const monEchelleXAutomatique = d3.scaleLinear()
            .domain(d3.extent(mesDonnees))
            .range([0,window.innerWidth])

        // obtenir la réciproque (identifier la valeur du domaine
        // à partir d'une valeur du range) avec .invert()
        console.log(echelleCourte(0))
        console.log(echelleCourte.invert(-3))

        // ajouter une zone cliquable à mon canevas
        canevas.on("click",fonctionClic);

        // définir la fonction de clic
        function fonctionClic(e){
            let position = d3.pointer(e,canevas)
            // j'affiche les positions x et y brutes
            console.log("Position brute : ",position)
            // afficher les données correspondant au x
            let donneesCorrespondantes = echelleCourte.invert(position[0]);
            console.log("Données de clic :", donneesCorrespondantes);
        }

        // générer des données continues
        // avec d3.range(min,max,evolution)
        const donneesContinues = d3.range(0,100,3);
        console.log("Donnees continues : ",donneesContinues)

        // créer une échelle pour les couleurs
        let echelleCouleurPage = d3.scaleLinear()
            .domain(d3.extent(donneesContinues))
            .range(['blue','red'])

        // créer des rectangles et faire évoluer la couleur
        // canevas.selectAll('rect')
        //     .data(donneesContinues)
        //     .enter()
        //     .append('rect')
        //         .attr('x', (d,i) => i * (window.innerWidth/donneesContinues.length))
        //         .attr('y',0)
        //         .attr('width', window.innerWidth/donneesContinues.length)
        //         .attr('height',window.innerHeight)
        //         .attr('fill', d => echelleCouleurPage(d))

        // ajouter des axes
        // pas d'axe sans échelle !

        // pour générer les valeurs on a une fonction "ticks"
        // 3 paramètres : minumum, maximum, évolution
        console.log("Ticks : ",d3.ticks(d3.min(donneesContinues),d3.max(donneesContinues),5))

        // créer une échelle puis ajouter un axe
        const echellePourAxe = d3.scaleLinear()
            .domain(d3.extent(donneesContinues))
            .range([100,window.innerWidth-100]);

        // créer l'axe qui prend pour paramètre une échelle
        const monAxe = d3.axisBottom(echellePourAxe).ticks(5)
        
        // il me faut encore ajouter l'axe à la visualisation
        canevas.append('g')
            .attr('transform','translate(10,300)')
            .call(monAxe)
        
        // ajouter des légendes

        let typeVehicule = ['pied','train','voiture','metro','bus','train'];

        // ajouter les bulles
        canevas.append('g').selectAll('circle')
            .data(typeVehicule)
            .enter()
            .append('circle')
                .attr('cx',50)
                .attr('cy', (d,i) => 50 + i *25)
                .attr('r', 10)
                .attr('fill', (d,i) => d3.schemeCategory10[i])
        // ajouter les textes
        canevas.append('g').selectAll('text')
            .data(typeVehicule)
            .enter()
            .append('text')
                .attr('x',70)
                .attr('y', (d,i) => 3 + 50 + i *25)
                .text(d => d)
                .attr('fill', (d,i) => d3.schemeCategory10[i])


    </script>
</body>

</html>