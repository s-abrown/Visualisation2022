<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTJ4</title>

    <style>
        svg {
            background-color: whitesmoke;
            margin: 1px solid;
        }
    </style>
</head>

<body>

<!-- Add 2 drop down inputs -->
<button onclick="update(El)">Data 1</button>
<button onclick="update(KM)">Data 2</button>

<!-- Drop down menu for the speakers Here is where you need to make a "data1" equivalent containing filtered by speaker stuff
<label for="speaker">Choose a speaker:</label>

<select name="speakerInput" id="speakerInput">
  <option value="El-p">El-P</option>
  <option value="Killer Mike">Killer Mike</option>

<!-- Drop down menu for the topics-->
<!---<label for="topic">Choose a topic:</label>

<select name="topicInput" id="topicInput">
    <option value="boasting">boasting</option>
    <option value="feelings">feelings</option> -->

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v6.js"></script>

</select>

    <script>
    
    // window 
    const width = window.innerWidth;
    const height = window.innerHeight; 

    // connect csv to the data
    d3.csv('RTJ4.csv', function (d) {
            return {
                speaker : d.speaker,
                boasting : +d.mentionBoasting,
                killerMike : +d.mentionKillerMike,
                elP : +d.mentionElP,
                family : +d.mentionFamily,
                disillusion : +d.mentionDisillusion,
                threatening : +d.mentionThreatening,
                anguish : +d.mentionAnguish,
                existentialism : +d.mentionExistentialism,
                poverty : +d.mentionPoverty,
                education : +d.mentionEducation,
                wealth : +d.mentionWealth,
                work : +d.mentionWork,
                crime : +d.mentionCrime,
                elections : +d.mentionElections,
                slavery : +d.mentionSlavery,
                racism : +d.mentionRacism,
                revolution : +d.mentionRevolution,
                antiReligion : +d.mentionAntiReligion,
                authority : +d.mentionAuthority,
                antiCapitalism : +d.mentionAntiCapitalism,
                antiPolice : +d.mentionAntiPolice,
                money : +d.mentionMoney,
                car : +d.mentionCar, 
                weapon : +d.mentionWeapon,
                socialMedia : +d.mentionSocialMedia,

                person : +d.mentionKillerMike + +d.mentionElP + +d.mentionFamily + +d.mentionOsamaBL + +d.mentionMohammedAli + +d.mentionKurtVonnegut + +d.mentionAynRand + +d.mentionDonaldTrump + +d.mentionToussainLouverture + +d.mentionNapoleonBonaparte + +d.mentionMalcolmX + +d.mentionMLK + +d.mentionJimmySavile + +d.mentionNoamChomsky + +d.mentionCharlesBukowski + +d.mentionDickGregory,
                feeling : +d.mentionBoasting + +d.mentionDisillusion + +d.mentionThreatening + +d.mentionAnguish + +d.mentionExistentialism,
                place : +d.mentonBrooklyn + +d.mentionNewYork + +d.mentionMiami + +d.mentionAtlanta + +d.mentionGuantanamo,
                state : +d.mentionPoverty + +d.mentionEducation + +d.mentionWealth,
                object : +d.mentionCar + +d.mentionMoney + +d.mentionWeapon + +d.mentionSocialMedia,
                action : +d.mentionWork + +d.mentionCrime,
                substanceUse : +d.mentionDrugs + +d.mentionAlcohol + +d.mentionTobacco,
                trackNumber : +d.trackNumber,

            }
        }).then(data => {
            // Check data:
            //console.log("My complete data set: ", data)

            // Creating the space for the graph with margins
            const margin = {top: 30, right: 30, bottom: 70, left: 60},
                w = 460 - margin.left - margin.right,
                h = 400 - margin.top - margin.bottom;
            // The radius of the pieplot is half the width or half the height (smallest one). I subtract a bit of margin.
            const radius = Math.min(width, height) / 2 - margin;

            // Creating the canvas
            const svg = d3.select("body")
                .append("svg")
                    .attr("width", w + margin.left + margin.right)
                    .attr("height", h + margin.top + margin.bottom)
                .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            // Looping through the dataset to obtain what we need for the graph:
            let boastingAlbumEl = 0
            let Elfeelings = 0
            let boastingAlbumKM = 0
            let KMfeelings = 0
            for (let i = 0; i < data.length; i++){
                if (data[i].speaker == 'el-p'){
                boastingAlbumEl += data[i].boasting
                Elfeelings += data[i].feeling
                }
                if (data[i].speaker == 'killerMike'){
                boastingAlbumKM += data[i].boasting
                KMfeelings += data[i].feeling
                }
            }
            // Datasets for the graph
            // For El-P
            const El = [
                {group: "boasting", value: boastingAlbumEl},
                {group: "feelings", value: Elfeelings},
            ]     
            // For KM
            const KM = [
                {group: "boasting", value: boastingAlbumKM}, 
                {group: "feelings", value: KMfeelings},
            ]

            // create 2 data_set //// Aka the 2 datasets above???????
            //const data1 = {a: 9, b: 20, c:30, d:8, e:12}
            //const data2 = {a: 6, b: 16, c:20, d:14, e:19, f:12}

            // set the color scale
            const color = d3.scaleOrdinal()
            //.domain(["a", "b", "c", "d", "e", "f"])
            .domain(["boasting", "feeling"])
            .range(d3.schemeDark2);

            // A function that create / update the plot for a given variable:
            function update(data) {
            // Compute the position of each group on the pie:
            const pie = d3.pie()
                .value(function(d) {return d[1]; })
                .sort(function(a, b) { return d3.ascending(a.key, b.key);} ) // This make sure that group order remains the same in the pie chart
            const data_ready = pie(Object.entries(data))
            // map to data
            const u = svg.selectAll("path")
                .data(data_ready)
            // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
            u
                .join('path')
                .transition()
                .duration(1000)
                .attr('d', d3.arc()
                .innerRadius(0)
                .outerRadius(radius)
                )
                .attr('fill', function(d){ return(color(d.data[0])) })
                .attr("stroke", "white")
                .style("stroke-width", "2px")
                .style("opacity", 1)
            }

            // Initialize the plot with the first dataset
            update(El)





        })
    

    

    </script>
    
</body>
</html>